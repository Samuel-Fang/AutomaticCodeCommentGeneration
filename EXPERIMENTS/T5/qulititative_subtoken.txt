def camera snapshot ( self , camera id , * * kwargs ) : api = self . api info [ 'camera' ] payload = dict ( { ' sid' : self . sid , 'api' : api [ 'name' ] , 'method' : 'Get Snapshot' , 'version' : api [ 'version' ] , 'camera Id' : camera id , } , * * kwargs ) response = self . get ( api [ 'url' ] , payload ) return response . content
def parse pattern ( pattern ) : if isinstance ( pattern , Number Pattern ) : return pattern def match number ( pattern ) : rv = number re . search ( pattern ) if rv is None : raise Value Error ( 'Invalid number pattern %r' % pattern ) return rv . groups ( ) pos pattern = pattern if ';' in pattern : pos pattern , neg pattern = pattern . split ( ';' , 1 ) pos prefix , number , pos suffix = match number ( pos pattern ) neg prefix , , neg suffix = match number ( neg pattern ) else : pos prefix , number , pos suffix = match number ( pos pattern ) neg prefix = '-' + pos prefix neg suffix = pos suffix if 'E' in number : number , exp = number . split ( 'E' , 1 ) else : exp = None if '@' in number : if '.' in number and '0' in number : raise Value Error ( 'Significant digit patterns can not contain ' '"@" or "0"' ) if '.' in number : integer , fraction = number . rsplit ( '.' , 1 ) else : integer = number fraction = '' def parse precision ( p ) : """Calculate the min and max allowed digits""" min = max = 0 for c in p : if c in '@0' : min += 1 max += 1 elif c == '#' : max += 1 elif c == ',' : continue else : break return min , max int prec = parse precision ( integer ) frac prec = parse precision ( fraction ) if exp : exp plus = exp . startswith ( '+' ) exp = exp . lstrip ( '+' ) exp prec = parse precision ( exp ) else : exp plus = None exp prec = None grouping = babel . numbers . parse grouping ( integer ) return Number Pattern ( pattern , ( pos prefix , neg prefix ) , ( pos suffix , neg suffix ) , grouping , int prec , frac prec , exp prec , exp plus )
def init connector ( self ) : self . using ssh = bool ( self . sshkey or self . sshserver ) if self . sshkey and not self . sshserver : self . sshserver = self . url . split ( '://' ) [ 1 ] . split ( ':' ) [ 0 ] if self . using ssh : if tunnel . try passwordless ssh ( self . sshserver , self . sshkey , self . paramiko ) : password = False else : password = getpass ( "SSH Password for %s: " % self . sshserver ) else : password = False def connect ( s , url ) : url = disambiguate url ( url , self . location ) if self . using ssh : self . log . debug ( "Tunneling connection to %s via %s" % ( url , self . sshserver ) ) return tunnel . tunnel connection ( s , url , self . sshserver , keyfile = self . sshkey , paramiko = self . paramiko , password = password , ) else : return s . connect ( url ) def maybe tunnel ( url ) : """like connect, but don't complete the connection (for use by heartbeat)""" url = disambiguate url ( url , self . location ) if self . using ssh : self . log . debug ( "Tunneling connection to %s via %s" % ( url , self . sshserver ) ) url , tunnelobj = tunnel . open tunnel ( url , self . sshserver , keyfile = self . sshkey , paramiko = self . paramiko , password = password , ) return url return connect , maybe tunnel
def sign ( self , value ) : value = want bytes ( value ) timestamp = base64 encode ( int to bytes ( self . get timestamp ( ) ) ) sep = want bytes ( self . sep ) value = value + sep + timestamp return value + sep + self . get signature ( value )
def initialize subcommand ( self , subc , argv = None ) : subapp , help = self . subcommands . get ( subc ) if isinstance ( subapp , basestring ) : subapp = import item ( subapp ) self . class . clear instance ( ) self . subapp = subapp . instance ( ) self . subapp . initialize ( argv )
def mk constant ( cnst syc ) : s dt = one ( cnst syc ) . S DT [ 1500 ] ( ) cnst lsc = one ( cnst syc ) . CNST LFSC [ 1502 ] . CNST LSC [ 1503 ] ( ) if s dt . Name == 'boolean' : return cnst lsc . Value . lower ( ) == 'true' if s dt . Name == 'integer' : return int ( cnst lsc . Value ) if s dt . Name == 'real' : return float ( cnst lsc . Value ) if s dt . Name == 'string' : return str ( cnst lsc . Value )
def pdf case report ( institute id , case name ) : institute obj , case obj = institute and case ( store , institute id , case name ) data = controllers . case report content ( store , institute obj , case obj ) if current app . config . get ( 'SQLALCHEMY DATABASE URI' ) : data [ 'coverage report' ] = controllers . coverage report contents ( store , institute obj , case obj , request . url root ) if case obj . get ( 'madeline info' ) is not None : with open ( os . path . join ( cases bp . static folder , 'madeline.svg' ) , 'w' ) as temp madeline : temp madeline . write ( case obj [ 'madeline info' ] ) html report = render template ( 'cases/case report.html' , institute = institute obj , case = case obj , format = 'pdf' , * * data ) return render pdf ( HTML ( string = html report ) , download filename = case obj [ 'display name' ] + ' ' + datetime . datetime . now ( ) . strftime ( "%Y-%m-%d" ) + ' scout.pdf' )
def backup ( self ) : if Py Funceble . CONFIGURATION [ "auto continue" ] : data to backup = { } configuration counter = Py Funceble . INTERN [ "counter" ] [ "number" ] data to backup [ Py Funceble . INTERN [ "file to test" ] ] = { "tested" : configuration counter [ "tested" ] , "up" : configuration counter [ "up" ] , "down" : configuration counter [ "down" ] , "invalid" : configuration counter [ "invalid" ] , } to save = { } to save . update ( self . backup content ) to save . update ( data to backup ) Dict ( to save ) . to json ( self . autocontinue log file )
def add run info ( self , idx , name = '' , timestamp = 42.0 , finish timestamp = 1.337 , runtime = 'forever and ever' , time = '>>Maybe time`s gone on strike' , completed = 0 , parameter summary = 'Not yet my friend!' , short environment hexsha = 'N/A' ) : if idx in self . single run ids : old name = self . single run ids [ idx ] del self . single run ids [ old name ] del self . single run ids [ idx ] del self . run information [ old name ] if name == '' : name = self . f wildcard ( '$' , idx ) self . single run ids [ name ] = idx self . single run ids [ idx ] = name info dict = { 'idx' : idx , 'timestamp' : timestamp , 'finish timestamp' : finish timestamp , 'runtime' : runtime , 'time' : time , 'completed' : completed , 'name' : name , 'parameter summary' : parameter summary , 'short environment hexsha' : short environment hexsha } self . run information [ name ] = info dict self . length = len ( self . run information )
def remove ancestors of ( self , node ) : if isinstance ( node , int ) : warnings . warn ( 'Calling remove ancestors of() with a node id is deprecated,' ' use a DAG Node instead' , Deprecation Warning , 2 ) node = self . id to node [ node ] anc = nx . ancestors ( self . multi graph , node ) for anc node in anc : if anc node . type == "op" : self . remove op node ( anc node )
